**Write a function that takes an array and returns all of its subsets.**

  ```ruby
    def subsets(array)
      return [[]] if array.empty?
    
      val = array[0]
      subs = array.drop(1).subsets
      subs += subs.map { |sub| array[val] + sub }
    
      subs
    end
  ```

**Write a function that will take a string and return the longest substring that is a palindrome.**

Your palindrome checker could reverse the string and compare it to the original, but that takes extra memory. It's more memory-efficient to keep two pointers and check if all letters that are equidistant from the middle are the same.

  ```ruby
    def longest_palindrome(string)
        candidates = []
        string.length.times { |i| candidates << palindrome_at(i, string) }
        candidates.max_by { |pal| pal.length }
    end
    
    def palindrome_at(position, string)
        longest = (position..position)
        for lower in (position - 1)..(position + 1)
          for  upper in position..(position + 1)
            while lower >= 0 && upper < string.length && string[lower] == string[upper]
              upper += 1
              lower -= 1
              longest = [longest, ((lower + 1)..(upper - 1))].max_by { |rng| rng.to_a.length }
            end
          end
        end
        string[longest]
    end
  ```