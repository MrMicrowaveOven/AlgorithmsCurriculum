## `subsets`

Write a function that takes an array and returns all of its subsets.

```ruby
def subsets(arr)
  return [[]] if arr.empty?
  val = arr[0]
  subs = subsets(arr[1..-1])
  new_subs = subs.map { |sub| sub + [val] }
  subs + new_subs
end
```

## `longest_palindrome`

Write a function that will take a string and return the longest
substring that is a palindrome.

Your palindrome checker could reverse the string and compare it to the
original, but that takes extra memory. It's more memory-efficient to
keep two pointers and check if all letters that are equidistant from
the middle are the same.

```ruby
def longest_palindrome(string)
  candidates = []
  string.length.times { |i| candidates << palindrome_at(i, string) }
  candidates.max_by { |pal| pal.length }
end

def palindrome_at(position, string)
  longest = (position..position)
  for lower in (position - 1)..(position + 1)
    for  upper in position..(position + 1)
      while lower >= 0 && upper < string.length && string[lower] == string[upper]
        upper += 1
        lower -= 1
        longest = [longest, ((lower + 1)..(upper - 1))].max_by { |rng| rng.to_a.length }
      end
    end
  end
  string[longest]
end
```
