## `uniq_subs`

Write a method that finds all the unique substrings for a word.

A results array and the `include?` method can be used to enforce
uniqueness, but it adds the time cost of iterating through that array
to check for inclusion. Keeping track of substrings in a hash is more
efficient.

```ruby
def uniq_subs(str)
  subs = {}

  str.length.times do |i|
    (i...str.length).each do |j|
      subs[str[i..j]] = true
    end
  end

  subs.keys
end
```

Time complexity: `O(n^2)`.

## `largest_continuous_subsum`

Given an array of integers (positive and negative) find the largest
continuous subsum (sum of a subarray).

You can solve this trivially in `O(n**2)` time by considering all
subarrays. Try to solve it in `O(n)` time with `O(1)` memory.

Hint: first figure out (in `O(n)` time), the best subsum that ends at
each position `i`. What is the relationship between the best subsum
ending at `i`, and the best subsum ending at `i + 1`?

```ruby
def lcs(arr)
  lcs_helper(arr)[:best_sum]
end

def lcs_helper(arr)
  if arr.empty?
    return { :best_sum => 0, :best_suffix_sum => 0 }
  end

  result = lcs_helper(arr.drop(1))
  old_best_sum, old_best_suffix_sum = result[:best_sum], result[:best_suffix_sum]
  new_best_suffix_sum = [old_best_suffix_sum + arr.first, arr.first].max
  new_best_sum = [old_best_sum, new_best_suffix_sum].max

  { :best_sum => new_best_sum,
    :best_suffix_sum => new_best_suffix_sum }
end
```
