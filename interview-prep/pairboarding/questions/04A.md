## `uniq_subs`

Write a method that finds all the unique substrings for a word.

A results array and the `include?` method can be used to enforce
uniqueness, but it adds the time cost of iterating through that array
to check for inclusion. Keeping track of substrings in a hash is more
efficient.

```ruby
def uniq_subs(str)
  subs = {}

  str.length.times do |i|
    (i...str.length).each do |j|
      subs[str[i..j]] = true
    end
  end

  subs.keys
end
```

Time complexity: `O(n^2)`.

## `sum`

You are given an array with integers (both positive and negative) in
any random order. Find the sub-array with the largest sum.

```ruby
# http://en.wikipedia.org/wiki/Maximum_subarray_problem
def max_sub_sum(arr)
  curr_sub = []
  curr_sum = 0

  max_sub = []
  max_sum = 0

  arr.each do |el|
    # keep track of the best subarray ending at the current element.
    if curr_sum + el > 0
      curr_sum += el
      curr_sub << el
    else
      curr_sum = 0
      curr_sub = []
    end

    if curr_sum > max_sum
      max_sum = curr_sum
      max_sub = curr_sub
    end
  end

  max_sub
end
```

Time Complexity: `O(n)`.
