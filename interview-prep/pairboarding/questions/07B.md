## `move_zeros`

Given an array, move all zeros to the end. The order of non-zero
elements does not matter. Algorithm should be O(n). Ex:

    move_zeros([1,2,0,3,4,0,5,6,0]) == [1,2,6,3,4,5,0,0,0]

Maintain two indices. One starts at the beginning, one starts at the
end. Increment start index until a zero value is found. Decrement end
index until non zero value is found. Swap values at start and end
indices continue, ending when start index > end index.

```ruby
def move_zeros(array)

  start = 0
  end = array.length -1

  while true
    until array[start] == 0
      start += 1
    end

    until array[end] != 0
      end -= 1
    end

    if start >= end
      break
    end

    array[start], array[end] = array[end], array[start]
  end
end
```

## `look_and_say`

Implement the 'look and say' function. 'Look and say' takes an input
array and outputs an array that describes the count of the elements in
the input array as they appear in order.

**Example:**

```ruby
look_and_say([1]) == [1,1] # there is one '1' in the input array
look_and_say([1,1]) == [2,1] # there are two '1's in the input array
look_and_say([2,1]) == [1,2,1,1] # there is one '2', followed by one '1' in the input array
look_and_say([1,2,1,1]) == [1,1,1,2,2,1] # is one '1', followed by one '2', followed by 2 '1's in the input array
```

Maintain a current count, maintain a current element. Push both onto
new array when a different element is detected.

```ruby
def look_and_say(array)
  # maintain a current count
  # maintain a current element
  # push both onto new array when a different element is detected

  cur_el = array[0]
  cur_count = 0

  output = []

  array.each do |el|
    if el == cur_el
      cur_count += 1
    else
      output << cur_count
      output << cur_el

      cur_el = el
      cur_count = 1
    end
  end

  # push the last set

  output << cur_count
  output << cur_el

  output
end
```

