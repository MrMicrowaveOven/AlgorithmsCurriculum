## `binary_search`

Implement binary search

```ruby
def binary_search(array, target)
  return nil if array.count == 0

  midpoint = length / 2
  case target <=> array[midpoint]
  when -1
    binary_search(array[0...midpoint], target)
  when 0
    midpoint
  when 1
    subproblem_answer =
      binary_search(array[(midpoint + 1)..-1], target)
    subproblem_answer.nil? ? nil : (midpoint + 1) + subproblem_answer
  end
end
```

Time complexity: `O(log(n))`

## `productify`

Given a list of numbers in an array, replace all the numbers with the
product of all other numbers. Do this in O(n) time without using
division.

```ruby
def productify(arr)
  left_arr, right_arr =
    Array.new(arr.size, arr[0]), Array.new(arr.size, arr[-1])
  results = Array.new(arr.size)

  # Build two arrays, where each term is the product of the previous
  # terms in arr, one starting from the left, the other from the right
  (1...arr.size).each do |i|
    left_arr[i] = arr[i] * left_arr[i-1]
    right_arr[-(i+1)] = arr[-(i+1)] * right_arr[-i]
  end

  # Assign values for result edge cases
  results[0], results [-1] = right_arr[1], left_arr[-2]

  # Multiply left and right terms to determine result
  (1...(arr.size-1)).each do |i|
    results[i] = left_arr[i-1]*right_arr[i+1]
  end

  results
end
```

